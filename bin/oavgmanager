#!/usr/bin/python
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; replace-tabs on;
#
#  Copyright (C) 2011-2016, it-novum GmbH <community@openattic.org>
#
#  openATTIC is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by
#  the Free Software Foundation; version 2.
#
#  This package is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

import sys
import os

from optparse import OptionParser

basedir = dict([
    line.strip().split("=") for line in open("/etc/default/openattic", "rb") if line.strip()
    ])["OADIR"].replace('"', '')

sys.path.append( basedir )
os.environ['DJANGO_SETTINGS_MODULE'] = 'settings'

from django.db.models import Q

from ifconfig.models import Host
from lvm.models import VolumeGroup, LogicalVolume
import lvm.signals as lvm_signals

class CmdLibrary(type):
    """ Meta class that keeps a library of defined checks. """
    handlers = {}

    def __init__( cls, name, bases, attrs ):
        type.__init__( cls, name, bases, attrs )
        if cls.command_name is not None:
            CmdLibrary.handlers[cls.command_name.lower()] = cls


class BaseCommand(object):
    __metaclass__ = CmdLibrary

    command_name = None
    command_args = None

    def populate_optparser(self, parser):
        pass

    def __call__(self, options, *args):
         raise NotImplemented()


class VgStartCommand(BaseCommand):
    """Mount all volumes. """

    command_name = "start"
    command_args = "[<vg>]"

    def populate_optparser(self, parser):
        parser.add_option("-o", "--hooks-only",  help="Only run hooks, do not actually activate/mount VGs.", default=False, action="store_true")
        parser.add_option("-f", "--force",       help="Mount even if the host does not seem right.", default=False, action="store_true")

    def __call__(self, options, vg=None):
        thishost = Host.objects.get_current()
        if vg is None:
            volgroups = VolumeGroup.all_objects.filter(Q(host__isnull=True)|Q(host=thishost))
        else:
            volgroup  = VolumeGroup.all_objects.get(name=vg)
            if not options.force and volgroup.host is not None and volgroup.host != thishost:
                print >> sys.stderr, "Volume Group '%s' is active on host '%s', cannot activate it here." % (
                    volgroup.name, volgroup.host.name )
                return 2
            volgroups = [volgroup]

        for volgroup in volgroups:
            lvm_signals.pre_activate.send(sender=volgroup, host=thishost)
            if not options.hooks_only:
                print "Mounting volumes of volume group '%s'..." % volgroup.name,
                if volgroup.host is None:
                    volgroup.host = thishost
                    volgroup.save()
            lvm_signals.activate.send(sender=volgroup)
            if not options.hooks_only:
                for lv in volgroup.logicalvolume_set.exclude(filesystem=""):
                    print lv.name,
                    lv.mount()
                print "done."
            lvm_signals.post_activate.send(sender=volgroup)

class VgStopCommand(BaseCommand):
    """Unmount all volumes. """

    command_name = "stop"
    command_args = "[<vg>]"

    def populate_optparser(self, parser):
        parser.add_option("-o", "--hooks-only",  help="Only run hooks, do not actually unmount/deactivate VGs.", default=False, action="store_true")
        parser.add_option("-f", "--force",       help="Unmount even if the host does not seem right", default=False, action="store_true")
        parser.add_option("-i", "--ignore-fail", help="Ignore failures", default=False, action="store_true")

    def __call__(self, options, vg=None):
        thishost = Host.objects.get_current()
        if not options.force:
            volgroups = VolumeGroup.objects.all()
        else:
            volgroups = VolumeGroup.all_objects.all()
        if vg is not None:
            volgroups = volgroups.filter(name=vg)
            if not volgroups:
                print >> sys.stderr, "Volume Group '%s' not found on this host." % vg
                return 1
        for volgroup in volgroups:
            lvm_signals.pre_deactivate.send(sender=volgroup)
            if not options.hooks_only:
                print "Unmounting volumes of volume group '%s'..." % volgroup.name,
                have_errors = False
                if not options.force:
                    vols = volgroup.logicalvolume_set.exclude(filesystem="")
                else:
                    vols = LogicalVolume.all_objects.filter(vg=volgroup).exclude(filesystem="")
                for lv in vols:
                    try:
                        print lv.name,
                        lv.unmount()
                    except Exception:
                        if not options.ignore_fail:
                            raise
                        else:
                            have_errors = True
                print "done."
            lvm_signals.deactivate.send(sender=volgroup)
            if not options.hooks_only and not have_errors:
                volgroup.host = None
                volgroup.save()
            lvm_signals.post_deactivate.send(sender=volgroup)

class VgRestartCommand(BaseCommand):
    """Remount all volumes. """

    command_name = "restart"
    command_args = "[<vg>]"

    def __call__(self, options, vg=None):
        ret = CmdLibrary.handlers["stop"]()(options, vg)
        if ret != 0:
            return ret
        return CmdLibrary.handlers["start"]()(options, vg)

class VgStatusCommand(BaseCommand):
    """See if any volumes are currently mounted. """

    command_name = "status"
    command_args = "[<vg>]"

    def populate_optparser(self, parser):
        parser.add_option("-v", "--verbose", help="Show mounted volumes", default=False, action="store_true")

    def __call__(self, options, vg=None):
        self.options = options

        try:
            self.thishost = Host.objects.get_current()
        except Exception, err:
            print "Got exception '%s' when checking, assuming the database isn't running and nothing is mounted." % unicode(err)
            return 3

        if vg is None:
            volgroups = VolumeGroup.all_objects.filter(Q(host__isnull=True)|Q(host=self.thishost))
            if not volgroups:
                print "No volume groups are running here."
                return 3

        else:
            volgroups = VolumeGroup.all_objects.filter(name=vg)
            if not volgroups:
                print "No such volume group exists."
                return 1

        return max([ self.vgstate(vg) for vg in volgroups ])

    def vgstate(self, volgroup):
        # Possible states for each volume group:
        # * VG does not run here       => 3
        # * VG running but empty       => 0
        # * VG running but not mounted => 3
        # * VG running and mounted     => 0
        # Boils down to: VG running here and total == mounted => 0, else 3

        if self.options.verbose:
            print "Checking VolumeGroup '%s'." % volgroup.name

        if volgroup.host != self.thishost:
            if self.options.verbose:
                if volgroup.host is not None:
                    print "VolumeGroup '%s' is running on '%s'." % (volgroup.name, volgroup.host.name)
                else:
                    print "VolumeGroup '%s' is inactive." % (volgroup.name)
            return 3

        vols = volgroup.logicalvolume_set.exclude(filesystem="")
        volcount = vols.count()
        mountedcount = 0
        for lv in vols:
            if lv.mounted:
                mountedcount += 1
                if self.options.verbose:
                    print "Volume '%s' is mounted." % lv.name
            elif self.options.verbose:
                print "Volume '%s' is not mounted." % lv.name

        print "%s: %d mounted, %d total." % (volgroup.name, mountedcount, volcount)
        if mountedcount == volcount:
            return 0
        else:
            return 3


class VgsCommand(BaseCommand):
    """See if any volumes are currently mounted. """

    command_name = "vgs"

    def populate_optparser(self, parser):
        parser.add_option("-q", "--quiet", help="No headline and no formatting", default=False, action="store_true")

    def __call__(self, options, vg=None):
        if not options.quiet:
            print "%-20s %s" % ("Volume Group", "Host")
            for vg in VolumeGroup.all_objects.all().order_by("name"):
                print "%-20s %s" % (vg.name, vg.host and vg.host.name or "<inactive>")
        else:
            for vg in VolumeGroup.all_objects.all().order_by("name"):
                print vg.name, vg.host and vg.host.name or ""


class MountCommand(BaseCommand):
    """ Mount a single volume. """

    command_name = "mount"
    command_args = "<vg> <volume>"

    def __call__(self, options, vg, volume):
        LogicalVolume.objects.get(vg__name=vg, name=volume).mount()


class UnmountCommand(BaseCommand):
    """ Unmount a single volume. """

    command_name = "unmount"
    command_args = "<vg> <volume>"

    def __call__(self, options, vg, volume):
        LogicalVolume.objects.get(vg__name=vg, name=volume).unmount()



def main():
    # Find the command argument
    command = None
    for arg in sys.argv[1:]:
        if arg[0] != "-":
            command = arg
            break

    usage = "%prog <command> [args]\n\nValid commands:\n"
    for cmdname, cmdclass in CmdLibrary.handlers.iteritems():
        usage += " * %-10s -- %s\n" % (cmdname, cmdclass.__doc__.strip())

    if command in CmdLibrary.handlers:
        cmdclass = CmdLibrary.handlers[command]()
    else:
        cmdclass = None

    if cmdclass is not None:
        if cmdclass.command_args is not None:
            usage += "\nArguments for command '%s': %s" % ( command, cmdclass.command_args )
        else:
            usage += "\nCommand '%s' does not take any arguments." % command

    parser = OptionParser(usage=usage)

    if cmdclass is None:
        parser.print_usage()
        if command is not None:
            print "no such command:", command
        return 1

    cmdclass.populate_optparser(parser)
    options, posargs = parser.parse_args()
    return cmdclass(options, *posargs[1:])

if __name__ == '__main__':
    sys.exit(main())

